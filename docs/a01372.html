<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>&#x202A;libpcl: &#x202A;Hash Table</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">&#x202A;libpcl
   </div>
   <div id="projectbrief">&#x202A;Portable C Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Hash Table</div>  </div>
</div><!--header-->
<div class="contents">

<p>&#x202A;This defines a hash table object and associated management functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01408.html">tag_pcl_htable_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&#x202A;Hash table entry object.  <a href="a01408.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01412.html">tag_pcl_htable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa535f1a16a04b2ad53bde938fa7511a4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a01408.html">tag_pcl_htable_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01372.html#gaa535f1a16a04b2ad53bde938fa7511a4">pcl_htable_entry_t</a></td></tr>
<tr class="memdesc:gaa535f1a16a04b2ad53bde938fa7511a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">&#x202A;Hash table entry object.  <a href="a01372.html#gaa535f1a16a04b2ad53bde938fa7511a4">More...</a><br /></td></tr>
<tr class="separator:gaa535f1a16a04b2ad53bde938fa7511a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga588a0320af552c98a6483cc0c7ea65ce"><td class="memItemLeft" align="right" valign="top">PCL_EXPORT <a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01372.html#ga588a0320af552c98a6483cc0c7ea65ce">pcl_htable</a> (int capacity)</td></tr>
<tr class="memdesc:ga588a0320af552c98a6483cc0c7ea65ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">&#x202A;Creates a new hash table object.  <a href="a01372.html#ga588a0320af552c98a6483cc0c7ea65ce">More...</a><br /></td></tr>
<tr class="separator:ga588a0320af552c98a6483cc0c7ea65ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0df966287253d3272adc900c8366223"><td class="memItemLeft" align="right" valign="top">PCL_EXPORT <a class="el" href="a01372.html#gaa535f1a16a04b2ad53bde938fa7511a4">pcl_htable_entry_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01372.html#gaa0df966287253d3272adc900c8366223">pcl_htable_lookup</a> (const <a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *ht, const void *key)</td></tr>
<tr class="memdesc:gaa0df966287253d3272adc900c8366223"><td class="mdescLeft">&#160;</td><td class="mdescRight">&#x202A;Lookup and return an entry.  <a href="a01372.html#gaa0df966287253d3272adc900c8366223">More...</a><br /></td></tr>
<tr class="separator:gaa0df966287253d3272adc900c8366223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6769a8cd9025a745233edaf51219e567"><td class="memItemLeft" align="right" valign="top">PCL_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01372.html#ga6769a8cd9025a745233edaf51219e567">pcl_htable_get</a> (const <a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *ht, const void *key)</td></tr>
<tr class="memdesc:ga6769a8cd9025a745233edaf51219e567"><td class="mdescLeft">&#160;</td><td class="mdescRight">&#x202A;Lookup an entry and return its value.  <a href="a01372.html#ga6769a8cd9025a745233edaf51219e567">More...</a><br /></td></tr>
<tr class="separator:ga6769a8cd9025a745233edaf51219e567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1264b974c59d4df60f955234778a5e6"><td class="memItemLeft" align="right" valign="top">PCL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01372.html#gad1264b974c59d4df60f955234778a5e6">pcl_htable_put</a> (<a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *ht, const void *key, void *value, bool unique)</td></tr>
<tr class="memdesc:gad1264b974c59d4df60f955234778a5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">&#x202A;Puts a key/value pair into the table.  <a href="a01372.html#gad1264b974c59d4df60f955234778a5e6">More...</a><br /></td></tr>
<tr class="separator:gad1264b974c59d4df60f955234778a5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2733c5c4b92e9bab34307f49c4ec8ec7"><td class="memItemLeft" align="right" valign="top">PCL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01372.html#ga2733c5c4b92e9bab34307f49c4ec8ec7">pcl_htable_remove</a> (<a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *ht, const void *key)</td></tr>
<tr class="memdesc:ga2733c5c4b92e9bab34307f49c4ec8ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">&#x202A;Remove an entry from the table.  <a href="a01372.html#ga2733c5c4b92e9bab34307f49c4ec8ec7">More...</a><br /></td></tr>
<tr class="separator:ga2733c5c4b92e9bab34307f49c4ec8ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4daae91aa6d60ba3f48ee666099f41d2"><td class="memItemLeft" align="right" valign="top">PCL_EXPORT <a class="el" href="a00113.html#a157296b59a693af5c94886de7d036223">pcl_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01372.html#ga4daae91aa6d60ba3f48ee666099f41d2">pcl_htable_keys</a> (const <a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *ht)</td></tr>
<tr class="memdesc:ga4daae91aa6d60ba3f48ee666099f41d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">&#x202A;Get hash table keys as an array.  <a href="a01372.html#ga4daae91aa6d60ba3f48ee666099f41d2">More...</a><br /></td></tr>
<tr class="separator:ga4daae91aa6d60ba3f48ee666099f41d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafceee6b86686728ca4833d3ad127a339"><td class="memItemLeft" align="right" valign="top">PCL_EXPORT <a class="el" href="a01372.html#gaa535f1a16a04b2ad53bde938fa7511a4">pcl_htable_entry_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01372.html#gafceee6b86686728ca4833d3ad127a339">pcl_htable_iter</a> (<a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *ht, int *index)</td></tr>
<tr class="memdesc:gafceee6b86686728ca4833d3ad127a339"><td class="mdescLeft">&#160;</td><td class="mdescRight">&#x202A;Iterate through a table's entries.  <a href="a01372.html#gafceee6b86686728ca4833d3ad127a339">More...</a><br /></td></tr>
<tr class="separator:gafceee6b86686728ca4833d3ad127a339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b25b5955d6abd1ef508a4106df9cfe2"><td class="memItemLeft" align="right" valign="top">PCL_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01372.html#ga8b25b5955d6abd1ef508a4106df9cfe2">pcl_htable_clear</a> (<a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *ht, bool shrink)</td></tr>
<tr class="memdesc:ga8b25b5955d6abd1ef508a4106df9cfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">&#x202A;Clear all entries from the table.  <a href="a01372.html#ga8b25b5955d6abd1ef508a4106df9cfe2">More...</a><br /></td></tr>
<tr class="separator:ga8b25b5955d6abd1ef508a4106df9cfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b9f6df4376aac1c35a5d87ebcff93dc"><td class="memItemLeft" align="right" valign="top">PCL_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01372.html#ga8b9f6df4376aac1c35a5d87ebcff93dc">pcl_htable_free</a> (<a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *ht)</td></tr>
<tr class="memdesc:ga8b9f6df4376aac1c35a5d87ebcff93dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">&#x202A;Release all resources used by the given hash table.  <a href="a01372.html#ga8b9f6df4376aac1c35a5d87ebcff93dc">More...</a><br /></td></tr>
<tr class="separator:ga8b9f6df4376aac1c35a5d87ebcff93dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p class="DocNodeLTR">This defines a hash table object and associated management functions. </p>
<p class="DocNodeLTR">This will preserve insertion order. Whenever an entry is put, it is added sequentially to an array of entry objects. To handle collisions, the entry objects are a linked list but use an integer value that represents the index of the next collision within the entry array. The key is hashed using Google's FarmHash and mod'd with the current table size to get the hashed index value. The hashed index value is an index to a second array (hashidx) of entry array indexes. Thus, looking up a hashed index within the <em>hashidx</em> array, will give you the entry array index, which is the beginning of the entry collision list. This is how the PCL hash table can preserve order: one array using hash index to find the index into the sequential array of entries.</p>
<dl class="section note DocNodeLTR"><dt>Note</dt><dd>&#x202A;The hashidx and entry array idea came directly from PHP's new hash table implementation released in 7.0. Better performance mostly due to limiting allocations. Just like PHP, PCL allocates the entry and hashidx arrays as one allocation: both with <em>capacity</em> elements. When an entry is removed, the entry array marks it as deleted but does not adjust the array to close the gap. An entry is marked as deleted by setting its <em>key</em> to <code>NULL</code>, which PCL treats as an invalid key. On rehash, the entry array is defragmented.</dd></dl>
<h3 class="DocNodeLTR"><a class="anchor" id="autotoc_md27"></a>
Default Hash Function</h3>
<p class="DocNodeLTR">Unlike PHP's implementation, PCL does not use the DJBX33A hash as its default, which stands for “Daniel J. Bernstein, Times 33 with Addition”. Google's farmhash proved to have far less collisions (on string data since DJBX33A is designed for string keys). In one test of 470,000 english words, Google's FarmHash had no collisions while DJBX33A had 320. Performance wise, they are about the same. Another benifit of Google's FarmHash, is that it is not designed for only string keys, which PCL requires since it allows for binary and string keys; and prefers to provide a single generalized hash function for both out of the box.</p>
<h3 class="DocNodeLTR"><a class="anchor" id="autotoc_md28"></a>
Customizing</h3>
<p class="DocNodeLTR">This implementation has the ability to set a minimum and maximum load factor. You can also set the <em>key_len</em> if not using string keys. If key_len is 0 (strings), then the default key_equals function uses strcmp. If key_len is not 0, memcmp is used. There are three callbacks to customize a hash table: <a class="el" href="a01412.html#a671a5819f733f2c3de67d78b2f118ac1" title="&#x202A;Called when an entry is being removed from the table.">pcl_htable_t.remove_entry</a>, <a class="el" href="a01412.html#a7e9adab84c43d9a11a7a2ca0ff70b81e" title="&#x202A;Compute a hash code for the given key.">pcl_htable_t.hashcode</a> and <a class="el" href="a01412.html#a57cdb09719a1350e1f053c01139eb363" title="&#x202A;Determine if two keys are equal.">pcl_htable_t.key_equals</a>. All of these customizations can be set after table creation.</p>
<h3 class="DocNodeLTR"><a class="anchor" id="autotoc_md29"></a>
Rehashing</h3>
<p class="DocNodeLTR">Rehashing is implemented by allocating a new entry and hashidx array that is either double the current size rounded up to the nearest prime or half the current size rounded up to the nearest prime. When the copy is complete, the old entry and hashidx arrays are freed. No hash codes are recomputed, since each entry caches its own hash code. The entry array is defragmented, meaning all deleted entries are removed.</p>
<h3 class="DocNodeLTR"><a class="anchor" id="autotoc_md30"></a>
Table Size Limitations</h3>
<p class="DocNodeLTR">The table can grow to ~50 million on 32-bit machines and ~1.6 billion on 64-bit machines. This table expands and contracts based on a max and min load factor &ndash; 0.75 and 0.20 respectively.</p>
<h3 class="DocNodeLTR"><a class="anchor" id="autotoc_md31"></a>
String and Binary Keys</h3>
<p class="DocNodeLTR">The PCL hash table supports binary keys, which are fixed-length and normally do not change for the life of the hash table. After creating a hash table, one can specify the key length in bytes or provide zero (the default) for variable-length keys (strings). For example, when using a UUID string as a key, each key would require 36 bytes. However, only 16 bytes per key if binary. In this case, you would set the key_len to 16. The default <code>key_equals</code> will use <code>memcmp</code> when <em>key_len</em> is not zero and <code>strcmp</code> otherwise.</p>
<h4 class="DocNodeLTR"><a class="anchor" id="autotoc_md32"></a>
UUID Key Example</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00059.html">pcl/htable.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00062.html">pcl/init.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00098.html">pcl/string.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;app/user.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *uuidtokey(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out, <span class="keyword">const</span> <span class="keywordtype">char</span> *uuid)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">char</span> *hex = <a class="code" href="a01381.html#ga1af4eb72cec27108e92a470640def1cc">pcl_strreplace</a>(uuid, <span class="stringliteral">&quot;-&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">  <a class="code" href="a01381.html#gafd8a5e2efd41dabad7002955280b004b">pcl_hex_decode</a>(out, 16, hex);</div>
<div class="line">  <a class="code" href="a01361.html#gab88b901c82e1010555b08ff6d39490f2">pcl_free</a>(hex);</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> remove_entry(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">void</span> *value, <span class="keywordtype">void</span> *userp)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="a00038.html#a9b58a1294d89c976dfbe4dc480e9dfb8">UNUSED</a>(userp);</div>
<div class="line">  <a class="code" href="a01361.html#gab88b901c82e1010555b08ff6d39490f2">pcl_free</a>(key);</div>
<div class="line">  app_user_free((app_user_t *) value);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="a01373.html#ga14907e41025b0abbdc02ef1f892bd9a2">pcl_init</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> num;</div>
<div class="line">  app_user_t **users = app_user_fetchall(&amp;num);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="a01412.html">pcl_htable_t</a> *ht = <a class="code" href="a01372.html#ga588a0320af552c98a6483cc0c7ea65ce">pcl_htable</a>(num);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// let htable know key length</span></div>
<div class="line">  ht-&gt;<a class="code" href="a01412.html#aaa2dc552577da2bba064c4d36d971c26">key_len</a> = 16;</div>
<div class="line">  ht-&gt;<a class="code" href="a01412.html#a671a5819f733f2c3de67d78b2f118ac1">remove_entry</a> = remove_entry;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> uuid[16];</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; num; i++)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">void</span> *key = memcmp(<a class="code" href="a01361.html#ga1df8575b9ae906470c782db9c26201e8">pcl_malloc</a>(16), uuidtokey(uuid, users[i]-&gt;uuid), 16);</div>
<div class="line">    <a class="code" href="a01372.html#gad1264b974c59d4df60f955234778a5e6">pcl_htable_put</a>(ht, key, users[i], <span class="keyword">true</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> *john = <span class="stringliteral">&quot;37462d98-371b-11eb-adc1-0242ac120002&quot;</span>;</div>
<div class="line">  pcl_user_t *user = <a class="code" href="a01372.html#ga6769a8cd9025a745233edaf51219e567">pcl_htable_get</a>(ht, uuidtokey(uuid, john));</div>
<div class="line"> </div>
<div class="line">  printf(<span class="stringliteral">&quot;%s\n&quot;</span>, user-&gt;surname);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="a01372.html#ga8b9f6df4376aac1c35a5d87ebcff93dc">pcl_htable_free</a>(ht);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="DocNodeLTR">One step further, is taking a 32 or 64-bit sequence value, like a <code>user_id</code>, and storing its value as the key pointer address: <code>key = (const void *)(uintptr_t) user_id</code>. This would require a custom key_equals (where key1 == key2 could be the implementation) and a custom hashcode callback (where return (uintptr_t) key; could be the implementation). This method is very efficient both in memory and performance, but only works if the numeric bit length is <code>&lt;=</code> the number of bits used by pointers. Also, user_id of 0 is invalid, since key's cannot be <code>NULL</code>, but it is uncommon to start sequence values like user_ids with 0. An example of this is below.</p>
<h4 class="DocNodeLTR"><a class="anchor" id="autotoc_md33"></a>
UserId Key Example</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00059.html">pcl/htable.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00062.html">pcl/init.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;app/user.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define IDTOKEY(id) (const void *) ((uintptr_t) (id))</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> key_equals(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b, <span class="keywordtype">size_t</span> key_len, <span class="keywordtype">void</span> *userp)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="a00038.html#a9b58a1294d89c976dfbe4dc480e9dfb8">UNUSED</a>(key_len || userp);</div>
<div class="line">  <span class="keywordflow">return</span> a == b; <span class="comment">// key addresses are user_ids, compare them directly.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> uintptr_t hashcode(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">size_t</span> key_len, <span class="keywordtype">void</span> *userp)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="a00038.html#a9b58a1294d89c976dfbe4dc480e9dfb8">UNUSED</a>(key_len || userp);</div>
<div class="line">  <span class="keywordflow">return</span> (uintptr_t) key; <span class="comment">// no need to hash keys, user_id is unique</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> remove_entry(<span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">void</span> *value, <span class="keywordtype">void</span> *userp)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="a00038.html#a9b58a1294d89c976dfbe4dc480e9dfb8">UNUSED</a>(key || userp);</div>
<div class="line">  app_user_free((app_user_t *) value); <span class="comment">// key doesn&#39;t need to be freed</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="a01373.html#ga14907e41025b0abbdc02ef1f892bd9a2">pcl_init</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> num_users;</div>
<div class="line">  app_user_t **users = app_user_fetchall(&amp;num_users);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// a table mapping a user_id =&gt; user.</span></div>
<div class="line">  <a class="code" href="a01412.html">pcl_htable_t</a> *ht = <a class="code" href="a01372.html#ga588a0320af552c98a6483cc0c7ea65ce">pcl_htable</a>(num_users);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// configuring a pcl_htable_t</span></div>
<div class="line">  ht-&gt;<a class="code" href="a01412.html#a671a5819f733f2c3de67d78b2f118ac1">remove_entry</a> = remove_entry;</div>
<div class="line">  ht-&gt;<a class="code" href="a01412.html#a7e9adab84c43d9a11a7a2ca0ff70b81e">hashcode</a> = hashcode;</div>
<div class="line">  ht-&gt;<a class="code" href="a01412.html#a57cdb09719a1350e1f053c01139eb363">key_equals</a> = key_equals;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ignored since example sets hashcode and key_equals. Set if your callbacks need it.</span></div>
<div class="line">  <span class="comment">//ht-&gt;key_len = 0;</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">//ht-&gt;min_loadfac = 0.13f;</span></div>
<div class="line">  <span class="comment">//ht-&gt;max_loadfac = 0.85f;</span></div>
<div class="line">  <span class="comment">//ht-&gt;userp = used_by_callbacks;</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// set key address to user_id</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; num_users; i++)</div>
<div class="line">    <a class="code" href="a01372.html#gad1264b974c59d4df60f955234778a5e6">pcl_htable_put</a>(ht, IDTOKEY(users[i]-&gt;<span class="keywordtype">id</span>), users[i], <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="a01361.html#gab88b901c82e1010555b08ff6d39490f2">pcl_free</a>(users);</div>
<div class="line"> </div>
<div class="line">  app_user_t *user = <a class="code" href="a01372.html#ga6769a8cd9025a745233edaf51219e567">pcl_htable_get</a>(ht, IDTOKEY(1982734));</div>
<div class="line"> </div>
<div class="line">  printf(<span class="stringliteral">&quot;%s\n&quot;</span>, user-&gt;name);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="a01372.html#ga8b9f6df4376aac1c35a5d87ebcff93dc">pcl_htable_free</a>(ht); <span class="comment">// calls remove_entry foreach entry in table</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa535f1a16a04b2ad53bde938fa7511a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa535f1a16a04b2ad53bde938fa7511a4">&#9670;&nbsp;</a></span>pcl_htable_entry_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a01408.html">tag_pcl_htable_entry</a> <a class="el" href="a01372.html#gaa535f1a16a04b2ad53bde938fa7511a4">pcl_htable_entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00059.html">pcl/htable.h</a>&gt;</code></p>

<p>&#x202A;Hash table entry object. </p>
<p class="DocNodeLTR">The overhead of each entry is 16 bytes on 32-bit machines and 32 bytes on 64-bit machines. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga588a0320af552c98a6483cc0c7ea65ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga588a0320af552c98a6483cc0c7ea65ce">&#9670;&nbsp;</a></span>pcl_htable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORT <a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a>* pcl_htable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00059.html">pcl/htable.h</a>&gt;</code></p>

<p>&#x202A;Creates a new hash table object. </p>
<p class="DocNodeLTR">All hash table callbacks are set to the default implementations as documented. After creating a hash table, you can assign callbacks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>&#x202A;initial capacity of hash table. This is rounded up to the nearest prime. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&#x202A;hash table pointer or NULL on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00518_source.html#l00062">62</a> of file <a class="el" href="a00518_source.html">htable.c</a>.</p>

<p class="reference">References <a class="el" href="a00059_source.html#l00261">tag_pcl_htable::capacity</a>, <a class="el" href="a00521_source.html#l00036">ipcl_htable_capacity()</a>, <a class="el" href="a00059_source.html#l00318">tag_pcl_htable::key_equals</a>, <a class="el" href="a00059_source.html#l00278">tag_pcl_htable::key_len</a>, <a class="el" href="a00038_source.html#l00112">max</a>, <a class="el" href="a00059_source.html#l00296">tag_pcl_htable::max_loadfac</a>, <a class="el" href="a00515_source.html#l00037">MAX_LOADFAC</a>, <a class="el" href="a00059_source.html#l00287">tag_pcl_htable::min_loadfac</a>, <a class="el" href="a00515_source.html#l00038">MIN_LOADFAC</a>, <a class="el" href="a01361.html#ga8f4cbae7a9d6191bceec2d2d1f04eb5d">pcl_zalloc()</a>, and <a class="el" href="a00017_source.html#l00287">R_TRC</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00716_source.html#l00045">pcl_json_obj()</a>.</p>

</div>
</div>
<a id="gaa0df966287253d3272adc900c8366223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0df966287253d3272adc900c8366223">&#9670;&nbsp;</a></span>pcl_htable_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORT <a class="el" href="a01372.html#gaa535f1a16a04b2ad53bde938fa7511a4">pcl_htable_entry_t</a>* pcl_htable_lookup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00059.html">pcl/htable.h</a>&gt;</code></p>

<p>&#x202A;Lookup and return an entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>&#x202A;pointer to hash table object </td></tr>
    <tr><td class="paramname">key</td><td>&#x202A;pointer to the key to lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&#x202A;pointer to the key's entry or NULL if not found or an error occurs. If not found, the last PCL error (pcl_errno) is set to PCL_ENOTFOUND. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00542_source.html#l00036">36</a> of file <a class="el" href="a00542_source.html">htable_lookup.c</a>.</p>

<p class="reference">References <a class="el" href="a00542_source.html#l00047">ipcl_htable_lookup()</a>, <a class="el" href="a00020_source.html#l00078">PCL_EINVAL</a>, <a class="el" href="a00017_source.html#l00145">R_SETERR</a>, and <a class="el" href="a00017_source.html#l00287">R_TRC</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00530_source.html#l00036">pcl_htable_get()</a>.</p>

</div>
</div>
<a id="ga6769a8cd9025a745233edaf51219e567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6769a8cd9025a745233edaf51219e567">&#9670;&nbsp;</a></span>pcl_htable_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORT void* pcl_htable_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00059.html">pcl/htable.h</a>&gt;</code></p>

<p>&#x202A;Lookup an entry and return its value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>&#x202A;pointer to hash table object </td></tr>
    <tr><td class="paramname">key</td><td>&#x202A;pointer to a key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&#x202A;value pointer or NULL if not found. values can be NULL. To detect an error verse a NULL value, check pcl_errno: if(value == NULL &amp;&amp; pcl_errno == PCL_EOKAY) success; </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00530_source.html#l00036">36</a> of file <a class="el" href="a00530_source.html">htable_get.c</a>.</p>

<p class="reference">References <a class="el" href="a00344_source.html#l00035">pcl_err_clear()</a>, <a class="el" href="a00542_source.html#l00036">pcl_htable_lookup()</a>, <a class="el" href="a00017_source.html#l00287">R_TRC</a>, and <a class="el" href="a00059_source.html#l00240">tag_pcl_htable_entry::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00719_source.html#l00036">pcl_json_objget()</a>.</p>

</div>
</div>
<a id="gad1264b974c59d4df60f955234778a5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1264b974c59d4df60f955234778a5e6">&#9670;&nbsp;</a></span>pcl_htable_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORT int pcl_htable_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unique</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00059.html">pcl/htable.h</a>&gt;</code></p>

<p>&#x202A;Puts a key/value pair into the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>&#x202A;pointer to hash table object </td></tr>
    <tr><td class="paramname">key</td><td>&#x202A;pointer to the key. This is shallow assignment. </td></tr>
    <tr><td class="paramname">value</td><td>&#x202A;pointer to the entry's value. This is shallow assignment. </td></tr>
    <tr><td class="paramname">unique</td><td>&#x202A;indicates if the put operation should enforce unique keys. When true, if a key exists the operation fails. When false, a matching entry's key and value are replaced with the given key and value; remove_entry called with old key and value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&#x202A;0 on success and -1 on error. For unique puts, pcl_errno is set to PCL_EEXISTS. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00545_source.html#l00037">37</a> of file <a class="el" href="a00545_source.html">htable_put.c</a>.</p>

<p class="reference">References <a class="el" href="a00017_source.html#l00306">BADARG</a>, <a class="el" href="a00059_source.html#l00261">tag_pcl_htable::capacity</a>, <a class="el" href="a00059_source.html#l00234">tag_pcl_htable_entry::code</a>, <a class="el" href="a00059_source.html#l00250">tag_pcl_htable::count</a>, <a class="el" href="a00059_source.html#l00263">tag_pcl_htable::entries</a>, <a class="el" href="a00059_source.html#l00265">tag_pcl_htable::hashidx</a>, <a class="el" href="a00542_source.html#l00047">ipcl_htable_lookup()</a>, <a class="el" href="a00548_source.html#l00038">ipcl_htable_rehash()</a>, <a class="el" href="a00059_source.html#l00237">tag_pcl_htable_entry::key</a>, <a class="el" href="a00059_source.html#l00296">tag_pcl_htable::max_loadfac</a>, <a class="el" href="a00059_source.html#l00231">tag_pcl_htable_entry::next</a>, <a class="el" href="a00020_source.html#l00068">PCL_EEXIST</a>, <a class="el" href="a00356_source.html#l00035">pcl_err_freeze()</a>, <a class="el" href="a00059_source.html#l00308">tag_pcl_htable::remove_entry</a>, <a class="el" href="a00017_source.html#l00065">SETERR</a>, <a class="el" href="a00017_source.html#l00262">TRC</a>, <a class="el" href="a00059_source.html#l00256">tag_pcl_htable::usedCount</a>, <a class="el" href="a00059_source.html#l00299">tag_pcl_htable::userp</a>, and <a class="el" href="a00059_source.html#l00240">tag_pcl_htable_entry::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00758_source.html#l00038">pcl_json_objput()</a>.</p>

</div>
</div>
<a id="ga2733c5c4b92e9bab34307f49c4ec8ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2733c5c4b92e9bab34307f49c4ec8ec7">&#9670;&nbsp;</a></span>pcl_htable_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORT int pcl_htable_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00059.html">pcl/htable.h</a>&gt;</code></p>

<p>&#x202A;Remove an entry from the table. </p>
<p class="DocNodeLTR">If the key does not exist, this call is silently ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>&#x202A;pointer to hash table object </td></tr>
    <tr><td class="paramname">key</td><td>&#x202A;pointer to the entry's key to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&#x202A;new count of entries or -1 on error </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00551_source.html#l00036">36</a> of file <a class="el" href="a00551_source.html">htable_remove.c</a>.</p>

<p class="reference">References <a class="el" href="a00017_source.html#l00306">BADARG</a>, <a class="el" href="a00059_source.html#l00261">tag_pcl_htable::capacity</a>, <a class="el" href="a00059_source.html#l00234">tag_pcl_htable_entry::code</a>, <a class="el" href="a00059_source.html#l00250">tag_pcl_htable::count</a>, <a class="el" href="a00059_source.html#l00263">tag_pcl_htable::entries</a>, <a class="el" href="a00059_source.html#l00331">tag_pcl_htable::hashcode</a>, <a class="el" href="a00059_source.html#l00265">tag_pcl_htable::hashidx</a>, <a class="el" href="a00548_source.html#l00038">ipcl_htable_rehash()</a>, <a class="el" href="a00059_source.html#l00237">tag_pcl_htable_entry::key</a>, <a class="el" href="a00059_source.html#l00318">tag_pcl_htable::key_equals</a>, <a class="el" href="a00059_source.html#l00278">tag_pcl_htable::key_len</a>, <a class="el" href="a00059_source.html#l00287">tag_pcl_htable::min_loadfac</a>, <a class="el" href="a00515_source.html#l00039">MINTBLSIZE</a>, <a class="el" href="a00059_source.html#l00231">tag_pcl_htable_entry::next</a>, <a class="el" href="a00059_source.html#l00308">tag_pcl_htable::remove_entry</a>, <a class="el" href="a00017_source.html#l00262">TRC</a>, <a class="el" href="a00059_source.html#l00299">tag_pcl_htable::userp</a>, and <a class="el" href="a00059_source.html#l00240">tag_pcl_htable_entry::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00776_source.html#l00036">pcl_json_objremove()</a>.</p>

</div>
</div>
<a id="ga4daae91aa6d60ba3f48ee666099f41d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4daae91aa6d60ba3f48ee666099f41d2">&#9670;&nbsp;</a></span>pcl_htable_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORT <a class="el" href="a00113.html#a157296b59a693af5c94886de7d036223">pcl_array_t</a>* pcl_htable_keys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00059.html">pcl/htable.h</a>&gt;</code></p>

<p>&#x202A;Get hash table keys as an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>&#x202A;pointer to hash table object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&#x202A;array on success and <code>NULL</code> on error. An empty table produces an empty array. This array must be freed by caller. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00539_source.html#l00036">36</a> of file <a class="el" href="a00539_source.html">htable_keys.c</a>.</p>

<p class="reference">References <a class="el" href="a00059_source.html#l00250">tag_pcl_htable::count</a>, <a class="el" href="a00059_source.html#l00263">tag_pcl_htable::entries</a>, <a class="el" href="a00059_source.html#l00237">tag_pcl_htable_entry::key</a>, <a class="el" href="a00143_source.html#l00036">pcl_array()</a>, <a class="el" href="a00026_source.html#l00153">pcl_array_push()</a>, and <a class="el" href="a00059_source.html#l00256">tag_pcl_htable::usedCount</a>.</p>

</div>
</div>
<a id="gafceee6b86686728ca4833d3ad127a339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafceee6b86686728ca4833d3ad127a339">&#9670;&nbsp;</a></span>pcl_htable_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORT <a class="el" href="a01372.html#gaa535f1a16a04b2ad53bde938fa7511a4">pcl_htable_entry_t</a>* pcl_htable_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00059.html">pcl/htable.h</a>&gt;</code></p>

<p>&#x202A;Iterate through a table's entries. </p>
<p class="DocNodeLTR">This automatically skips deleted entries. </p><div class="fragment"><div class="line"><span class="comment">// typical usage</span></div>
<div class="line"><span class="keywordtype">int</span> index = 0;</div>
<div class="line"><a class="code" href="a01408.html">pcl_htable_entry_t</a> *ent;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the iteration is always insertion order</span></div>
<div class="line"><span class="keywordflow">while</span>((ent = <a class="code" href="a01372.html#gafceee6b86686728ca4833d3ad127a339">pcl_htable_iter</a>(ht, &amp;index)))</div>
<div class="line">  printf(<span class="stringliteral">&quot;%d] %s\n&quot;</span>, index - 1, ent-&gt;<a class="code" href="a01408.html#a9eb073a4e7f31790de2c4f6b2ea74081">key</a>); <span class="comment">// -1 since iter() increments</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// can also use this to retrieve the N-th entry</span></div>
<div class="line"><span class="keywordtype">int</span> index = 9; <span class="comment">// 10-th entry inserted</span></div>
<div class="line"><a class="code" href="a01408.html">pcl_htable_entry_t</a> *ent = <a class="code" href="a01372.html#gafceee6b86686728ca4833d3ad127a339">pcl_htable_iter</a>(ht, &amp;index);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>&#x202A;pointer to a hash table </td></tr>
    <tr><td class="paramname">index</td><td>&#x202A;pointer to an integer that must be &gt;= 0 on the first call. This is typically set to 0 to iterate through all entries. After the first call, this value shoulod remain unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&#x202A;pointer to the next entry or <code>NULL</code> when complete. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00536_source.html#l00035">35</a> of file <a class="el" href="a00536_source.html">htable_iter.c</a>.</p>

<p class="reference">References <a class="el" href="a00059_source.html#l00263">tag_pcl_htable::entries</a>, <a class="el" href="a00059_source.html#l00237">tag_pcl_htable_entry::key</a>, and <a class="el" href="a00059_source.html#l00256">tag_pcl_htable::usedCount</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00689_source.html#l00036">ipcl_json_encode_object()</a>.</p>

</div>
</div>
<a id="ga8b25b5955d6abd1ef508a4106df9cfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b25b5955d6abd1ef508a4106df9cfe2">&#9670;&nbsp;</a></span>pcl_htable_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORT void pcl_htable_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shrink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00059.html">pcl/htable.h</a>&gt;</code></p>

<p>&#x202A;Clear all entries from the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>&#x202A;pointer to hash table object </td></tr>
    <tr><td class="paramname">shrink</td><td>&#x202A;when true, the table will be shrunk down to the smallest table size; 17. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00524_source.html#l00037">37</a> of file <a class="el" href="a00524_source.html">htable_clear.c</a>.</p>

<p class="reference">References <a class="el" href="a00059_source.html#l00261">tag_pcl_htable::capacity</a>, <a class="el" href="a00059_source.html#l00250">tag_pcl_htable::count</a>, <a class="el" href="a00059_source.html#l00263">tag_pcl_htable::entries</a>, <a class="el" href="a00059_source.html#l00265">tag_pcl_htable::hashidx</a>, <a class="el" href="a00533_source.html#l00037">ipcl_htable_init()</a>, <a class="el" href="a00059_source.html#l00237">tag_pcl_htable_entry::key</a>, <a class="el" href="a00515_source.html#l00039">MINTBLSIZE</a>, <a class="el" href="a01361.html#gab88b901c82e1010555b08ff6d39490f2">pcl_free()</a>, <a class="el" href="a00059_source.html#l00308">tag_pcl_htable::remove_entry</a>, <a class="el" href="a00059_source.html#l00256">tag_pcl_htable::usedCount</a>, <a class="el" href="a00059_source.html#l00299">tag_pcl_htable::userp</a>, and <a class="el" href="a00059_source.html#l00240">tag_pcl_htable_entry::value</a>.</p>

</div>
</div>
<a id="ga8b9f6df4376aac1c35a5d87ebcff93dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b9f6df4376aac1c35a5d87ebcff93dc">&#9670;&nbsp;</a></span>pcl_htable_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCL_EXPORT void* pcl_htable_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00113.html#a837674424510bcf55b9b1eaa8acf639f">pcl_htable_t</a> *&#160;</td>
          <td class="paramname"><em>ht</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00059.html">pcl/htable.h</a>&gt;</code></p>

<p>&#x202A;Release all resources used by the given hash table. </p>
<p class="DocNodeLTR">If a remove_entry callback is set on the given hash table, it will be called for each entry. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>&#x202A;pointer to hash table object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&#x202A;always returns NULL, which is useful as an assignment and free in a single line: <code>my_obj-&gt;ht = pcl_htable_free(my_obj-&gt;ht)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00527_source.html#l00036">36</a> of file <a class="el" href="a00527_source.html">htable_free.c</a>.</p>

<p class="reference">References <a class="el" href="a00059_source.html#l00263">tag_pcl_htable::entries</a>, <a class="el" href="a00059_source.html#l00237">tag_pcl_htable_entry::key</a>, <a class="el" href="a01361.html#gab88b901c82e1010555b08ff6d39490f2">pcl_free()</a>, <a class="el" href="a00059_source.html#l00308">tag_pcl_htable::remove_entry</a>, <a class="el" href="a00059_source.html#l00256">tag_pcl_htable::usedCount</a>, <a class="el" href="a00059_source.html#l00299">tag_pcl_htable::userp</a>, and <a class="el" href="a00059_source.html#l00240">tag_pcl_htable_entry::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00701_source.html#l00038">pcl_json_free()</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aa01412_html_a57cdb09719a1350e1f053c01139eb363"><div class="ttname"><a href="a01412.html#a57cdb09719a1350e1f053c01139eb363">tag_pcl_htable::key_equals</a></div><div class="ttdeci">bool(* key_equals)(const void *key1, const void *key2, size_t key_len, void *userp)</div><div class="ttdoc">Determine if two keys are equal.</div><div class="ttdef"><b>Definition:</b> <a href="a00059_source.html#l00318">htable.h:318</a></div></div>
<div class="ttc" id="aa01381_html_ga1af4eb72cec27108e92a470640def1cc"><div class="ttname"><a href="a01381.html#ga1af4eb72cec27108e92a470640def1cc">pcl_strreplace</a></div><div class="ttdeci">PCL_EXPORT char * pcl_strreplace(const char *subject, const char *from, const char *to)</div><div class="ttdoc">Replace all occurances of a search string with a replacement string.</div></div>
<div class="ttc" id="aa01372_html_gafceee6b86686728ca4833d3ad127a339"><div class="ttname"><a href="a01372.html#gafceee6b86686728ca4833d3ad127a339">pcl_htable_iter</a></div><div class="ttdeci">PCL_EXPORT pcl_htable_entry_t * pcl_htable_iter(pcl_htable_t *ht, int *index)</div><div class="ttdoc">Iterate through a table's entries.</div><div class="ttdef"><b>Definition:</b> <a href="a00536_source.html#l00035">htable_iter.c:35</a></div></div>
<div class="ttc" id="aa01361_html_ga1df8575b9ae906470c782db9c26201e8"><div class="ttname"><a href="a01361.html#ga1df8575b9ae906470c782db9c26201e8">pcl_malloc</a></div><div class="ttdeci">void * pcl_malloc(size_t n)</div><div class="ttdoc">Allocate dynamic memory.</div></div>
<div class="ttc" id="aa01372_html_ga8b9f6df4376aac1c35a5d87ebcff93dc"><div class="ttname"><a href="a01372.html#ga8b9f6df4376aac1c35a5d87ebcff93dc">pcl_htable_free</a></div><div class="ttdeci">PCL_EXPORT void * pcl_htable_free(pcl_htable_t *ht)</div><div class="ttdoc">Release all resources used by the given hash table.</div><div class="ttdef"><b>Definition:</b> <a href="a00527_source.html#l00036">htable_free.c:36</a></div></div>
<div class="ttc" id="aa01372_html_gad1264b974c59d4df60f955234778a5e6"><div class="ttname"><a href="a01372.html#gad1264b974c59d4df60f955234778a5e6">pcl_htable_put</a></div><div class="ttdeci">PCL_EXPORT int pcl_htable_put(pcl_htable_t *ht, const void *key, void *value, bool unique)</div><div class="ttdoc">Puts a key/value pair into the table.</div><div class="ttdef"><b>Definition:</b> <a href="a00545_source.html#l00037">htable_put.c:37</a></div></div>
<div class="ttc" id="aa01372_html_ga6769a8cd9025a745233edaf51219e567"><div class="ttname"><a href="a01372.html#ga6769a8cd9025a745233edaf51219e567">pcl_htable_get</a></div><div class="ttdeci">PCL_EXPORT void * pcl_htable_get(const pcl_htable_t *ht, const void *key)</div><div class="ttdoc">Lookup an entry and return its value.</div><div class="ttdef"><b>Definition:</b> <a href="a00530_source.html#l00036">htable_get.c:36</a></div></div>
<div class="ttc" id="aa01408_html"><div class="ttname"><a href="a01408.html">tag_pcl_htable_entry</a></div><div class="ttdoc">Hash table entry object.</div><div class="ttdef"><b>Definition:</b> <a href="a00059_source.html#l00228">htable.h:229</a></div></div>
<div class="ttc" id="aa00059_html"><div class="ttname"><a href="a00059.html">htable.h</a></div></div>
<div class="ttc" id="aa01412_html_a7e9adab84c43d9a11a7a2ca0ff70b81e"><div class="ttname"><a href="a01412.html#a7e9adab84c43d9a11a7a2ca0ff70b81e">tag_pcl_htable::hashcode</a></div><div class="ttdeci">uintptr_t(* hashcode)(const void *key, size_t key_len, void *userp)</div><div class="ttdoc">Compute a hash code for the given key.</div><div class="ttdef"><b>Definition:</b> <a href="a00059_source.html#l00331">htable.h:331</a></div></div>
<div class="ttc" id="aa00038_html_a9b58a1294d89c976dfbe4dc480e9dfb8"><div class="ttname"><a href="a00038.html#a9b58a1294d89c976dfbe4dc480e9dfb8">UNUSED</a></div><div class="ttdeci">#define UNUSED(...)</div><div class="ttdef"><b>Definition:</b> <a href="a00038_source.html#l00102">defs.h:102</a></div></div>
<div class="ttc" id="aa01381_html_gafd8a5e2efd41dabad7002955280b004b"><div class="ttname"><a href="a01381.html#gafd8a5e2efd41dabad7002955280b004b">pcl_hex_decode</a></div><div class="ttdeci">PCL_EXPORT int pcl_hex_decode(void *buf, size_t size, const char *hex)</div><div class="ttdoc">Decode a hexadecimal string.</div><div class="ttdef"><b>Definition:</b> <a href="a01115_source.html#l00054">hex_decode.c:54</a></div></div>
<div class="ttc" id="aa01361_html_gab88b901c82e1010555b08ff6d39490f2"><div class="ttname"><a href="a01361.html#gab88b901c82e1010555b08ff6d39490f2">pcl_free</a></div><div class="ttdeci">void * pcl_free(void *p)</div><div class="ttdoc">Free memory space.</div></div>
<div class="ttc" id="aa01408_html_a9eb073a4e7f31790de2c4f6b2ea74081"><div class="ttname"><a href="a01408.html#a9eb073a4e7f31790de2c4f6b2ea74081">tag_pcl_htable_entry::key</a></div><div class="ttdeci">const void * key</div><div class="ttdoc">entry key</div><div class="ttdef"><b>Definition:</b> <a href="a00059_source.html#l00237">htable.h:237</a></div></div>
<div class="ttc" id="aa01372_html_ga588a0320af552c98a6483cc0c7ea65ce"><div class="ttname"><a href="a01372.html#ga588a0320af552c98a6483cc0c7ea65ce">pcl_htable</a></div><div class="ttdeci">PCL_EXPORT pcl_htable_t * pcl_htable(int capacity)</div><div class="ttdoc">Creates a new hash table object.</div><div class="ttdef"><b>Definition:</b> <a href="a00518_source.html#l00062">htable.c:62</a></div></div>
<div class="ttc" id="aa00062_html"><div class="ttname"><a href="a00062.html">init.h</a></div></div>
<div class="ttc" id="aa01412_html"><div class="ttname"><a href="a01412.html">tag_pcl_htable</a></div><div class="ttdef"><b>Definition:</b> <a href="a00059_source.html#l00243">htable.h:244</a></div></div>
<div class="ttc" id="aa01412_html_a671a5819f733f2c3de67d78b2f118ac1"><div class="ttname"><a href="a01412.html#a671a5819f733f2c3de67d78b2f118ac1">tag_pcl_htable::remove_entry</a></div><div class="ttdeci">void(* remove_entry)(const void *key, void *value, void *userp)</div><div class="ttdoc">Called when an entry is being removed from the table.</div><div class="ttdef"><b>Definition:</b> <a href="a00059_source.html#l00308">htable.h:308</a></div></div>
<div class="ttc" id="aa01412_html_aaa2dc552577da2bba064c4d36d971c26"><div class="ttname"><a href="a01412.html#aaa2dc552577da2bba064c4d36d971c26">tag_pcl_htable::key_len</a></div><div class="ttdeci">size_t key_len</div><div class="ttdoc">Key length in bytes.</div><div class="ttdef"><b>Definition:</b> <a href="a00059_source.html#l00278">htable.h:278</a></div></div>
<div class="ttc" id="aa00098_html"><div class="ttname"><a href="a00098.html">string.h</a></div></div>
<div class="ttc" id="aa01373_html_ga14907e41025b0abbdc02ef1f892bd9a2"><div class="ttname"><a href="a01373.html#ga14907e41025b0abbdc02ef1f892bd9a2">pcl_init</a></div><div class="ttdeci">PCL_EXPORT void pcl_init(void)</div><div class="ttdoc">Initializes the PCL library.</div><div class="ttdef"><b>Definition:</b> <a href="a00560_source.html#l00062">init.c:62</a></div></div>
<!-- HTML footer for doxygen 1.8.20-->
<!-- start footer part -->
</body>
</html>
